# 大实验报告：我的**五子棋AI**
## 使用说明
1. 点击`setup.exe` 将`Five.exe`安装到与`res`文件夹在同一目录下.
2. 点击`Five.exe`进行五子棋游戏的游玩.
3. 游玩时弹出命令提示行属于正常现象,那里会有游戏方式的指导的.
---
## 内容说明
### 做什么?
既然是**五子棋AI**,那必然是要包含以下内容的:
1. 游玩五子棋的框架
2. 人工智能评估棋局 & 双方落子
此外我还扩展了一些功能:
3. 开局点右键让人机先下
4. 悔棋, ~~还可以还没下棋就悔棋,~~ 而且可以回滚多步,从星罗棋布到荒无人烟都行
    - 当然不能在输的时候悔棋,那就没意思了
5. 部分音效~~(偷的素材)~~
> 本来想添加背景音乐的,但是考虑到本人比较喜欢听歌的缘故,故将背景音乐的选择权交给玩家了XD
6. **游戏规则:** 五子棋基本规则(无禁手/无时间限制) ~~因为鄙人并不懂五子棋,下不过小学生那种,因此并不需要禁手来制约自己可怜的胜率罢(悲)~~
## 怎么做?
这里就得详细讲了.
### 备战
#### 使用工具
1. *Visual Studio 2022*(本来是用vsc的删了,但是不得不装回来)
2. *EasyX* 图形库(因为上面那个括号的原因导致这个插件装了一个星期才装上)
#### 库
4个自己做的头文件算**库**吗?🤔当然*EasyX*肯定是算的
#### 配置开发环境
配置分两步走,第一步按网上的教程将*Visual Studio*装好,第二步将*EasyX*图形库装进*Visual Studio*,完成!
~~忘了第三步新建文件~~
### 实战
#### 模块分类
所谓**五子棋AI**,那就是有**五子棋**和**AI**两部分嘛.根据五子棋的性质,可以分出**棋子和棋盘**模块;根据AI的理解,又可以分出**AI**一个模块,再加上**人**的模块;游戏进行也需要**控制**模块,那就分为四个模块吧!
> 每一个模块都确实是以类为单位的,就像天上只有一个太阳
1. `Chess.cpp & Chess.h` 棋子&棋盘模块
2. `ChessGame.cpp & ChessGame.h` 游戏控制模块
3. `AI.cpp & AI.h` 人工智能模块
4. `Man.cpp & Man.h` 人类功能模块
四个模块之间相辅相成,彼此依附,少了任何一块游戏都不能运行.我觉得就好比数学中的并集.
#### 实现代码(**主要**)
> 这部分是重头戏了,得好好讲讲.由于版面原因,就不展示众多头文件的内容了.
分完类以后就是补充各个接口的代码内容了.但补充也得讲个顺序吧.
0. 各种要素的初始化
	类的调用肯定离不开初始化的.因此,在每个模块开头都必然有一段**init**的过程.
	`ChessGame.cpp`
	```C++
	ChessGame::ChessGame(Man* man, AI* ai, Chess* chess)
	{
		this->man = man;
		this->ai = ai;
		this->chess = chess;
		man->init(chess);
		ai->init(chess);
	}
	```
	这里就展示控制模块的初始化,其他类的初始化都大同小异了.
	这样就可以让各个类联系起来,劲往一处使才能完成五子棋的大业.
1. 把棋盘画出来
	`Chess.cpp`
	```C++
	//这部分代码是位于Chess::init()里面的
  		//创建游戏窗口
		initgraph(790, 781);
		//显示棋盘图片
		loadimage(0, "res/棋盘4.jpg");
		// 加载黑棋和白棋的图片
		loadimage(&chessBlackImg, "res/black.png", chessSize, chessSize, true);
		//使得棋盘方格大小与棋子大小相同 chessSize是根据棋盘一个四方格的大小所定义的棋子大小,定义在别的地方
		loadimage(&chessWhiteImg, "res/white.png", chessSize, chessSize, true);
		loadimage(&chessBlackCur, "res/black2.png", chessSize, chessSize, true);
		loadimage(&chessWhiteCur, "res/white2.png", chessSize, chessSize, true);
		loadimage(&chessRed, "res/red.png", chessSize, chessSize, true);
	```
	用到的是EasyX里面的图形库的各种加载图形的函数,把棋盘棋子等图像都加载出来,方便以后调用.资源是自己找的.
2. 补充棋盘逻辑
	如何将棋子下到棋盘里?这是一个重要的问题.将棋盘框架补充完整,才有后面的人机下棋对弈.那么该怎么实现人类的落子呢?
	- 人类点击→落子的实现
		`依然是Chess.cpp`
		```C++
		bool Chess::clickBoard(int x, int y, ChessPos* pos)//ChessPos 是棋子位置的结构体
		{
			//marginX/Y是棋盘边缘像素的横纵坐标
			int col = (x - marginX) / chessSize;
			int row = (y - marginY) / chessSize;
			//这两步是先默认点击点是棋盘中离鼠标最近的左上角
			int leftTopPosX;
			int leftTopPosY;
			//减去左侧、上侧边界 整除每一格宽度（四舍五入） 就能得到横纵坐标,方便定位落子
			int offset = chessSize * 0.4;
			int len;
			mini.data = 789;//随意设的一个值,它比棋盘本身还大
			bool ret = false;//本函数返回值
			for (int i = 0;i < 4;i++) {
				//点击点是否在左上角 左下角 右上角 右下角的判定
				leftTopPosX = marginX + chessSize * (col + node[i][0]);
				/*
				这里的node表示了每一个边角,为了将它写进循环里,显得表达式比较奇怪 如下
				int node[4][2] = { {0,0} , {1,0} , {0,1} , {1,1} };0.左上角 1.左下角 2.右上角 3.右下角
				*/
				leftTopPosY = marginY + chessSize * (row + node[i][1]);
				len = sqrt(pow(x - leftTopPosX, 2) + pow(y - leftTopPosY, 2));
				//根据点的距离公式求出点击点和,这里将最小值和序号并成了一个结构体
				if (len <= mini.data) {
					mini.data = len;
					mini.i = i;
				}
			}
			//让本位于左上角的落子点落到精确的位置
			col += node[mini.i][0];
			row += node[mini.i][1];
			pos->col = col;
			pos->row = row;
			if (!chessMap[pos->row][pos->col]) {
				ret = true;
				//如果这个地方已经有子了,就不能落子了.
			}
			return ret;
		}
		```
	- 让落子具象化(有图像和声音)
		事实上,光点击了棋盘其实并不能让棋子*看起来*落在棋盘上,因为此时还没有加载棋子的图片.因此又有:
		`Chess.cpp`
		```C++
		void Chess::chessDown(ChessPos* pos, chess_kind_t kind/*棋子的种类*/)
		{
			mciSendString("play res/down7.wav", 0, 0, 0);//落子音效
			int x = marginX + chessSize * pos->col - 0.5 * chessSize;
			int y = marginY + chessSize * pos->row - 0.5 * chessSize;
			//让落子落在纵横线中间
		//	if (kind == CHESS_WHITE)
		//		putimagePNG(x, y, &chessWhiteImg);
		//	else putimagePNG(x, y, &chessBlackImg);
			//这段注释是以前显示落子的方式,后来为了加入悔棋等功能,改为每落一次子就刷新了一次画面
			updateGameMap(pos);
			drawMap();
		}
		void Chess::updateGameMap(ChessPos* pos)
		{
			lastPos = *pos;//记录上一次落子的位置
			chessRecord.push(lastPos);//将上次落子位置压入栈内,方便悔棋寻找
			if (firstStrike)//firstStrike是谁先手的意思.
				chessMap[pos->row][pos->col] = playerFlag ? CHESS_BLACK : CHESS_WHITE;
				//谁先手谁是黑子,然后根据落子方加载那一方的图片
			else
				chessMap[pos->row][pos->col] = playerFlag ? CHESS_WHITE : CHESS_BLACK;
			playerFlag = !playerFlag;
			//playerFlag是落子方的判断,此时是为了交换落子方的表述
		}
		void Chess::drawMap()
		{
			cleardevice();//EasyX的清屏操作
			loadimage(0, "res/棋盘4.jpg");
			for (int i = 0;i < gradeSize;i++) {
				for (int j = 0;j < gradeSize;j++) {
					//对于棋盘上每一个子,均把它们加载到棋盘上
					int x = marginX + chessSize * j - 0.5 * chessSize;
					int y = marginY + chessSize * i - 0.5 * chessSize;
					switch (chessMap[i][j])//chessMap,二维数组存储游戏地图
					{
					case 1://1,即CHESS_BLACK,是黑棋的代表 
						putimagePNG(x, y, (i == lastPos.row && j == lastPos.col) ? &chessBlackCur : &chessBlackImg);
						break;
					case -1://-1,即CHESS_WHITE,是白棋的代表
						putimagePNG(x, y, (i == lastPos.row && j == lastPos.col) ? &chessWhiteCur : &chessWhiteImg);
						break;
					case 2://2是红棋,一方五子连珠后显示,游戏结束
						putimagePNG(x, y, &chessRed);
						break;
					}
				}
			}
		}
		```
		这样,由**点击→落子→记录→上图**,落子的功能就可以实现了.在棋子这方面设计完毕后,还需要在人类和人机那边配合一下接口才行.人机的落子只需要去掉**点击**这一步就行.
		`这次是Man.cpp`
		```C++
		void Man::go()
		{
			MOUSEMSG msg;//获取鼠标点击信息
			ChessPos pos;
			//通过chess对象来调用判断落子是否有效，以及落子功能
			bool mouse;
			while (1) {
				msg = GetMouseMsg();
				if (msg.uMsg == WM_RBUTTONDOWN) {
					mouse = false;//悔棋按钮
					break;
				}
				if (msg.uMsg == WM_LBUTTONDOWN && chess->clickBoard(msg.x, msg.y, &pos)) {
					mouse = true;//落子按钮
					break;
				}
			}
			system("cls");//后面会显示AI计分地图,清屏是为了刷新
			//下面是黑棋落子或者悔棋
			if (mouse)
				chess->chessDown(&pos, CHESS_BLACK);
			else chess->recall();//黑子悔棋
		}
		```
		`然后是AI.cpp`
		```C++
		void AI::go()
		{
			ChessPos pos;
			if (chess->chessRecord.empty()) {
				pos.col = 7;
				pos.row = 7;
			}//如果白棋先手,那么默认落在中央
			else {
				pos = think();
				srand((unsigned)time(NULL));
				int stime = rand() % 3000;
				Sleep(stime);
				//计算机假装思考陪人类玩一下
			}
			chess->chessDown(&pos, CHESS_WHITE);
		}
		```
		问题来了,上文还有一个putimagePNG()函数,这是什么函数?众所周知,EasyX图形库显示的图片并不是透明的,这会让下棋的观感变得很差.因此我引用了[这个地方的透明化PNG函数](https://blog.csdn.net/pzjdoytt/article/details/125198101),快速消除图片周围的白框,舒服多了.这里就不再展示这个透明函数了.
		至此,游戏的底层框架已差不多写完了.
3. 补充游戏控制部分
	五子棋是回合制游戏,游戏控制很简单:你一步,我一步.
	`ChessGame.cpp`
	```C++
	//对局（开始五子棋游戏）
	void ChessGame::play()
	{
		chess->init();//初始化少不了
		while (1) {
			//先由棋手落子
			if (chess->playerFlag) {
				man->go();
				if (chess->checkOver()) {
					//checkOver()函数检查是否有五子连珠,若有,进行下一局游戏
					chess->init();
					continue;
				}
			}
			//再由机器落子
			if (!chess->playerFlag) {
				ai->go();
				if (chess->checkOver()) {
					chess->init();
					continue;
				}
			}
		}
	}
	```
	此时**五子棋**已经可以下了.但是有一个很严重的问题:现在AI还不会思考,现在只是人类在自娱自乐而已.重中之重来了:设计AI算法.
4. 完善AI落子部分
	怎么让AI动起来?方法有很多种,这里我采取的是其中比较简单的一种:计算地图上每一点的得分.对于让AI行动方法的讨论我会放到评估AI棋力的部分里面.这里先谈谈怎么让AI思考.
	- 初始化
		包括类的初始化,启动AI计分地图等.
		`AI.cpp(接下来都是)`
		```C++
		void AI::init(Chess* chess)
		{
			this->chess = chess;
			int size = chess->getGradeSize();//获取棋盘大小
			for (int i = 0;i < size;i++) {
				vector<int> row;
				for (int j = 0;j < size;j++) {
					row.push_back(0);
				}
				scoreMap.push_back(row);//创建计分地图二维动态数组
			}
		}
		```
	- 填充计分地图并取最大值
		我的AI的思考方式:对于每一个空位,若AI选择落在这个位置,对横纵斜四个方向分别评估其可形成的棋型,对于每一种棋型给予一定的梯度分数,将四个方向的分数加起来即为本位置得分.如此操作直到地图被填满,然后随机取得分最大值的位置之一落子.
		```C++
		//计算每一个空位的得分
		void AI::calculateScore()
		{
			//评分数组清零
			for (int i = 0;i < scoreMap.size();i++) {
				for (int j = 0;j < scoreMap[i].size();j++) {
					scoreMap[i][j] = 0;
				}
			}
			ChessPos pos_t, curPos;
			//pos_t:为了评估棋型所定义的活动位置;curPos:当前评估位置
			int score[2][2][5] = 
			{ 
				{ { 0,10,30,60,20000 }/*一个空白位置*/,{ 0,10,40,150,20000 }/*两个空白位置*/ }, //黑棋
				{ { 5,10,50,200,30000 }/*一个空白位置*/,{ 5,10,75,10000,30000 }/*两个空白位置*/ },//白棋
			};
			//计分数表;表示的含义→第一维度：黑白棋0/1；第二维度0/1：空白位置个数-1；第三维度：棋子个数对应的评分	
			int size = chess->getGradeSize();
			for (curPos.row = 0;curPos.row < size;curPos.row++) {
				for (curPos.col = 0;curPos.col < size;curPos.col++) {
					//对每个棋盘上的点计算
					if (chess->getChessData(&curPos) != 0) continue;//棋盘上这点为空 才计算
					for (int y = -1;y <= 1;y++) {
						for (int x = 0;x <= 1;x++) {
							//x和y是为了确定棋型时活动方向的"向量"
							int personNum = 0/*黑棋在这个方向上连续有多少个棋子*/, AINum = 0,/*白棋在这个方向上有多少个连续的棋子*/emptyNum = 0;//该方向上空白位置的个数
							if (x == 0 && y == 0) continue;//0,0 不活动 排除
							if (y == -1 && x == 0) continue;//-1,0 不合要求排除
							//至此四个方向都可以被评估棋型了
							//下面是假设人类在该位置落子会构成人类的什么情形
							for (int dir = -1;dir <= 1;dir += 2) {
								//活动方向:正负两个方向都要取
								for (int i = 1;i <= 4;i++) {
									pos_t.row = curPos.row + i * y * dir;
									pos_t.col = curPos.col + i * x * dir;
									//从当前位置发生活动位移以评估棋型
									if (posJudge(pos_t, CHESS_BLACK)) {
										//posJudge函数可以判定当前位置是否位于棋盘内且是否满足类型(黑白)要求,若满足,对应连续棋子数+1
										personNum++;
									}
									else if (posJudge(pos_t, EMPTY)) {
										//如果遇到空白则停止计数.最终可以得到
										emptyNum++;
										break;
									}
									else {
										//出边界就出循环
										break;
									}
								}
							}
							if (personNum == 1 || personNum == 4) {
								//对于人类,为当前位置评分
								scoreMap[curPos.row][curPos.col] += score[0][0][personNum];
								//这里区分人类连子数1和4为一个分支条件,有两种原因:此时空白位置可能为0使得数组越界;或者无论空白位置有多少评分增加值均相同.
							}
							else if (emptyNum == 1 || emptyNum == 2) {
								//else if的条件确保加分时数组不越界
								scoreMap[curPos.row][curPos.col] += score[0][emptyNum - 1][personNum];
								//评分数组立大功,避免大量的重复影响观感
							}
							emptyNum = 0;
							//让空白位置重置,下面是为AI棋子评分部分,同理
							for (int dir = -1;dir <= 1;dir += 2) {
								for (int i = 1;i <= 4;i++) {
									pos_t.row = curPos.row + i * y * dir;
									pos_t.col = curPos.col + i * x * dir;
									if (posJudge(pos_t, CHESS_WHITE)) {
										AINum++;
									}
									else if (posJudge(pos_t, EMPTY)) {
										emptyNum++;
										break;
									}
									else {
										break;
									}
								}
							}
							if (AINum <= 1 || AINum >= 4) {
								scoreMap[curPos.row][curPos.col] += score[1][0][AINum];
							}
							else if (emptyNum == 1 || emptyNum == 2) {
								scoreMap[curPos.row][curPos.col] += score[1][emptyNum - 1][AINum];
							}
						}
					}
				}
			}
		}
		//AI将根据评分地图思考决策落子位置(取最大值,若有多个,随机取之一)
		ChessPos AI::think()
		{
			AI::calculateScore();//计算得分
			ChessPos pos = { 0,0 };
			int maxScore = 0;//记录最大值
			vector<ChessPos> record;//记录最大值得分所在位置的动态数组
			//下面是打印AI评分地图的代码,以供参考
			printf("      ");
			for (int i = 65;i < scoreMap.size()+65;i++) {
				printf("%-6c", i);
			}
			cout << endl;
			for (int j = 0;j < scoreMap.size();j++) {
				printf("%-6d", j+1);
				//下面是记录最大值的代码
				for (int i = 0;i < scoreMap.size();i++) {
					printf("%-6d", scoreMap[j][i]);
					if (maxScore < scoreMap[j][i]) {
						record.clear();//既然最大值已被刷新,之前的记录就全没用了
						pos.row = j;
						pos.col = i;
						record.push_back(pos);//将最大值的位置压入记录中
						maxScore = scoreMap[j][i];
					}
					else if (maxScore == scoreMap[j][i]) {
						pos.row = j;
						pos.col = i;
						record.push_back(pos);//将最大值之一的位置压入记录中
					}
				}
				cout << endl;
			}
			printf("maxscore:%d\n", maxScore);
			//此处评分
			srand((unsigned)time(NULL));//取随机数
			int index = rand() % record.size();
			return record[index];//随机落子在一个最大值所在位置
		}
		```
	- AI落子
		这部分已经在**2.**里面涉及到了,也就是`void AI::go()`函数.就不再重复了.
5. 判定结束和胜负
	只要场上出现一方**五子连珠**,游戏结束.对于五子连珠的判断不必像计算AI地图那样遍历所有空闲点,只需要搜索上次落子的位置上下左右对角线方向是否有**五个相同类型的棋子**(不为空)就行了.
	`Chess.cpp`
	```C++
	bool Chess::checkWin()
	{
		int row = lastPos.row;//lastPos上次落子的位置
		int col = lastPos.col;
		for (int x = 0;x <= 1;x++) {
			for (int y = -1;y <= 1;y++) { //经典的方向决定式子 x 和 y
			//i的意思是在连续五个点
				if ((x == 0 && y == 0) || (x == 0 && y == -1)) continue;//像上面AI地图一样,排除两个不需要的方向	
				for (int i = 0;i < 5;i++) {
					//一次判断，共4次，连续5子均同色则游戏结束
					int cnt = 0;
					ChessPos pos;//每一次连续确认的起点
					pos.row = row - i * y;
					pos.col = col - i * x;
					if (!borderCheck(pos.row, pos.col) || !borderCheck(pos.row + 4 * y, pos.col + 4 * x)) {
						//防止数组越界,超出地图之外的判断
						continue;
					}
					for (int j = 1;j <= 4;j++) {
						if (chessMap[pos.row][pos.col] == chessMap[pos.row + j * y][pos.col + j * x] && chessMap[pos.row][pos.col] != 0) {
							//判断连续位置是否为同一类型
							cnt++;
						}
					}
					if (cnt == 4) {
						showResult(x, y, pos);//后文会涉及到的展示结果函数
						cout << "Gameover!" << endl;
						return true;
					}
				}
			}
		}
		return false;
	}
	```
	后面显示胜负页面的代码就不展示了.
6. 补充功能
	- 显示五子连珠
	因为我比较菜,有时候输了都不知道怎么输的,所以我需要知道我输在哪里~~(当然也可以是赢在哪里)~~,因此设计了显示赢棋的部分.
	```C++
	void Chess::showResult(int x,int y,ChessPos pos)
	{
		if (borderCheck(pos.row, pos.col) && borderCheck(pos.row + 4 * y, pos.col + 4 * x)) {
			for (int i = 0;i < 5;i++) {
				chessMap[pos.row + i * y][pos.col + i * x] = 2;
			}
			drawMap();//加载出棋盘和棋子的图片
			Sleep(3000);//3秒钟明白18种输法
		}
	}
	```
	- 悔棋,和让AI先手的功能
	因为我比较菜,很容易看漏棋子导致失误送赢,而且**测试的时候也需要多步回滚看记录**,所以设计了悔棋的功能.
	悔棋的主要思想其实和浏览文件夹里面的`返回`是差不多的,都是将记录压入和退出栈的过程.知道这一点后,悔棋就不难设计了.
	```C++
	void Chess::recall()
	{
		if (chessRecord.empty()) {
			//如果开局悔棋,则视为让机器先手
			playerFlag = !playerFlag;
			firstStrike = false;
			return;
		}
		else if (chessRecord.size() == 1) {
			//如果在机器先手的时候选择悔棋,取消此操作
			cout << "你现在不能撤回！请先下第一步棋。" << endl;
			return;
		}	
		for (int i = 0;i < 2;i++) {
			int row = chessRecord.top().row;
			int col = chessRecord.top().col;
			chessMap[row][col] = 0;
			chessRecord.pop();
			//删除记录即可,甚至不需要交换棋权
		}
		drawMap();//重新绘制棋盘和棋子的图片
	}
	```
**跌跌撞撞中好像五子棋AI就做完了.**
#### 运行
1. 运行截图
	![开始界面](/pic1.png)
	![已经结束咧](/pic2.png)
	![AI地图显示](/pic3.png)
2. 程序运行速度
	emm这个怎么说呢,你说它快吧,有时候会闪屏,应该是*EasyX*的原因;你说它卡吧,落子秒下又是真的.我觉得下五子棋应该用不到帧率来描述吧!AI思考又不需要时间,一切都是Sleep()的错!(笑)
3. 程序大小
	约5M,其中大部分都是图片音效资源占用空间,代码本身当然是不占空间的.
#### 棋力评价